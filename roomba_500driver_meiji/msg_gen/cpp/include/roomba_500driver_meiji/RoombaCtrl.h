/* Auto-generated by genmsg_cpp for file /home/kendemu/catkin_ws/src/roomba_robot_meiji/roomba_500driver_meiji/msg/RoombaCtrl.msg */
#ifndef ROOMBA_500DRIVER_MEIJI_MESSAGE_ROOMBACTRL_H
#define ROOMBA_500DRIVER_MEIJI_MESSAGE_ROOMBACTRL_H
#include <string>
#include <vector>
#include <map>
#include <ostream>
#include "ros/serialization.h"
#include "ros/builtin_message_traits.h"
#include "ros/message_operations.h"
#include "ros/time.h"

#include "ros/macros.h"

#include "ros/assert.h"

#include "geometry_msgs/Twist.h"

namespace roomba_500driver_meiji
{
template <class ContainerAllocator>
struct RoombaCtrl_ {
  typedef RoombaCtrl_<ContainerAllocator> Type;

  RoombaCtrl_()
  : mode(0)
  , velocity(0)
  , radius(0)
  , cntl()
  , r_pwm(0)
  , l_pwm(0)
  , song_melody()
  {
  }

  RoombaCtrl_(const ContainerAllocator& _alloc)
  : mode(0)
  , velocity(0)
  , radius(0)
  , cntl(_alloc)
  , r_pwm(0)
  , l_pwm(0)
  , song_melody(_alloc)
  {
  }

  typedef int32_t _mode_type;
  int32_t mode;

  typedef int32_t _velocity_type;
  int32_t velocity;

  typedef int32_t _radius_type;
  int32_t radius;

  typedef  ::geometry_msgs::Twist_<ContainerAllocator>  _cntl_type;
   ::geometry_msgs::Twist_<ContainerAllocator>  cntl;

  typedef int16_t _r_pwm_type;
  int16_t r_pwm;

  typedef int16_t _l_pwm_type;
  int16_t l_pwm;

  typedef std::vector<uint8_t, typename ContainerAllocator::template rebind<uint8_t>::other >  _song_melody_type;
  std::vector<uint8_t, typename ContainerAllocator::template rebind<uint8_t>::other >  song_melody;

  enum { DRIVE = 0 };
  enum { SAFE = 1 };
  enum { FULL = 2 };
  enum { POWER = 3 };
  enum { SPOT = 4 };
  enum { CLEAN = 5 };
  enum { MAX = 6 };
  enum { MOTORS = 7 };
  enum { FORCE_SEEK_DOCK = 8 };
  enum { WAKEUP = 9 };
  enum { MOTORS_OFF = 10 };
  enum { DRIVE_DIRECT = 11 };
  enum { DOCK = 12 };
  enum { DRIVE_PWM = 13 };
  enum { DRIVE_FB = 14 };
  enum { SONG = 15 };
  enum { DEFAULT_VELOCITY = 200 };
  enum { STRAIGHT_RADIUS = 32768 };
  enum { TURN_CLOCK = -1 };
  enum { TURN_CNT_CLOCK = 1 };

  typedef boost::shared_ptr< ::roomba_500driver_meiji::RoombaCtrl_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::roomba_500driver_meiji::RoombaCtrl_<ContainerAllocator>  const> ConstPtr;
}; // struct RoombaCtrl
typedef  ::roomba_500driver_meiji::RoombaCtrl_<std::allocator<void> > RoombaCtrl;

typedef boost::shared_ptr< ::roomba_500driver_meiji::RoombaCtrl> RoombaCtrlPtr;
typedef boost::shared_ptr< ::roomba_500driver_meiji::RoombaCtrl const> RoombaCtrlConstPtr;


template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const  ::roomba_500driver_meiji::RoombaCtrl_<ContainerAllocator> & v)
{
  ros::message_operations::Printer< ::roomba_500driver_meiji::RoombaCtrl_<ContainerAllocator> >::stream(s, "", v);
  return s;}

} // namespace roomba_500driver_meiji

namespace ros
{
namespace message_traits
{
template<class ContainerAllocator> struct IsMessage< ::roomba_500driver_meiji::RoombaCtrl_<ContainerAllocator> > : public TrueType {};
template<class ContainerAllocator> struct IsMessage< ::roomba_500driver_meiji::RoombaCtrl_<ContainerAllocator>  const> : public TrueType {};
template<class ContainerAllocator>
struct MD5Sum< ::roomba_500driver_meiji::RoombaCtrl_<ContainerAllocator> > {
  static const char* value() 
  {
    return "cef9b586878cf4721995492e63a047cb";
  }

  static const char* value(const  ::roomba_500driver_meiji::RoombaCtrl_<ContainerAllocator> &) { return value(); } 
  static const uint64_t static_value1 = 0xcef9b586878cf472ULL;
  static const uint64_t static_value2 = 0x1995492e63a047cbULL;
};

template<class ContainerAllocator>
struct DataType< ::roomba_500driver_meiji::RoombaCtrl_<ContainerAllocator> > {
  static const char* value() 
  {
    return "roomba_500driver_meiji/RoombaCtrl";
  }

  static const char* value(const  ::roomba_500driver_meiji::RoombaCtrl_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator>
struct Definition< ::roomba_500driver_meiji::RoombaCtrl_<ContainerAllocator> > {
  static const char* value() 
  {
    return "byte DRIVE=0\n\
byte SAFE=1\n\
byte FULL=2\n\
byte POWER=3\n\
byte SPOT=4\n\
byte CLEAN=5\n\
byte MAX=6\n\
byte MOTORS=7\n\
byte FORCE_SEEK_DOCK=8\n\
byte WAKEUP=9\n\
byte MOTORS_OFF=10\n\
byte DRIVE_DIRECT=11\n\
byte DOCK=12\n\
byte DRIVE_PWM=13\n\
byte DRIVE_FB=14\n\
byte SONG=15\n\
\n\
\n\
int32 DEFAULT_VELOCITY=200\n\
int32 STRAIGHT_RADIUS=32768\n\
byte TURN_CLOCK=-1\n\
byte TURN_CNT_CLOCK=1\n\
int32 mode\n\
int32 velocity\n\
int32 radius\n\
geometry_msgs/Twist cntl\n\
int16 r_pwm\n\
int16 l_pwm\n\
\n\
uint8[] song_melody\n\
\n\
================================================================================\n\
MSG: geometry_msgs/Twist\n\
# This expresses velocity in free space broken into its linear and angular parts.\n\
Vector3  linear\n\
Vector3  angular\n\
\n\
================================================================================\n\
MSG: geometry_msgs/Vector3\n\
# This represents a vector in free space. \n\
\n\
float64 x\n\
float64 y\n\
float64 z\n\
";
  }

  static const char* value(const  ::roomba_500driver_meiji::RoombaCtrl_<ContainerAllocator> &) { return value(); } 
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

template<class ContainerAllocator> struct Serializer< ::roomba_500driver_meiji::RoombaCtrl_<ContainerAllocator> >
{
  template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
  {
    stream.next(m.mode);
    stream.next(m.velocity);
    stream.next(m.radius);
    stream.next(m.cntl);
    stream.next(m.r_pwm);
    stream.next(m.l_pwm);
    stream.next(m.song_melody);
  }

  ROS_DECLARE_ALLINONE_SERIALIZER;
}; // struct RoombaCtrl_
} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::roomba_500driver_meiji::RoombaCtrl_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const  ::roomba_500driver_meiji::RoombaCtrl_<ContainerAllocator> & v) 
  {
    s << indent << "mode: ";
    Printer<int32_t>::stream(s, indent + "  ", v.mode);
    s << indent << "velocity: ";
    Printer<int32_t>::stream(s, indent + "  ", v.velocity);
    s << indent << "radius: ";
    Printer<int32_t>::stream(s, indent + "  ", v.radius);
    s << indent << "cntl: ";
s << std::endl;
    Printer< ::geometry_msgs::Twist_<ContainerAllocator> >::stream(s, indent + "  ", v.cntl);
    s << indent << "r_pwm: ";
    Printer<int16_t>::stream(s, indent + "  ", v.r_pwm);
    s << indent << "l_pwm: ";
    Printer<int16_t>::stream(s, indent + "  ", v.l_pwm);
    s << indent << "song_melody[]" << std::endl;
    for (size_t i = 0; i < v.song_melody.size(); ++i)
    {
      s << indent << "  song_melody[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.song_melody[i]);
    }
  }
};


} // namespace message_operations
} // namespace ros

#endif // ROOMBA_500DRIVER_MEIJI_MESSAGE_ROOMBACTRL_H

